import { Metadata, Dictionary, TypeConstructor } from './models';
export declare class Collection<T> {
    activeId: number | string;
    lastUpdated: Date;
    metadata: Metadata;
    _ctor: TypeConstructor<T>;
    _items: Dictionary<T>;
    static AddItem<T>(state: Dictionary<T>, key: number | string, item: T): Dictionary<T>;
    static BuildCollection<T>(items: T[], findByKey?: string): Collection<T>;
    static BuildDictionaryFromArray<T>(value: any[], key?: string): Dictionary<T>;
    static BuildFromArray<T>(items: T[], findByKey?: string): Collection<T>;
    static BuildItems<T>(items: T[], findByKey?: string): Dictionary<T>;
    static Filter<T>(item: T, path: string): boolean;
    static FilterAnd<T>(item: T, paths: string[]): boolean;
    static FilterOr<T>(item: T, paths: string[]): boolean;
    static RemoveItem<T>(state: Dictionary<T>, key: number | string): Dictionary<T>;
    constructor(ctor?: TypeConstructor<T>);
    readonly active: T;
    ctor: TypeConstructor<T>;
    readonly count: number;
    readonly defaultItem: T;
    readonly empty: boolean;
    readonly instance: Collection<T>;
    items: Dictionary<T>;
    readonly keys: number[] | string[];
    readonly asArray: T[];
    readonly itemsArray: T[];
    toArray(): T[];
    activate(id: number, key?: string): Collection<T>;
    addItem(item: T, key?: number | string): Collection<T>;
    addItems(items: T[], key?: string): Collection<T>;
    build(items: Dictionary<T>, ctor?: TypeConstructor<Collection<T>>): Collection<T>;
    buildItem(existingItem: T, newItem: any, ctor?: TypeConstructor<T>): T;
    buildItems(items: T[], ctor?: TypeConstructor<T>): T[];
    copyItems(): Dictionary<T>;
    delete(key: string | number): Collection<T>;
    filter(f: (item: T) => boolean): Collection<T>;
    filterBy(f: (item: T, index?: number) => boolean): T[];
    filterItems(f: (item: T, index?: number) => boolean): T[];
    findBy(f: (item: T) => boolean): T;
    get(id: number | string): T;
    map(f: (item: T) => T): Collection<T>;
    query(path: string): T[];
    queryAnd(paths: string[]): T[];
    queryOr(paths: string[]): T[];
    removeAt(key: number | string): Collection<T>;
    removeItem(key: number | string): Collection<T>;
    removeItems(filter: (item: T) => boolean, key?: string): void;
    removeKeys(keys: any[]): void;
    replace(itemsArray: T[]): Collection<T>;
    replaceItems(items: T[], filter?: (item: T) => boolean): Collection<T>;
    setValue(value: Collection<T>): Collection<T>;
    update(value: any | any[], ctor?: TypeConstructor<T>, key?: string): Collection<T>;
    updateItem(item: any, key: number | string, ctor?: TypeConstructor<T>): Collection<T>;
    updateItems(items: any[], ctor?: TypeConstructor<T>, key?: string): Collection<T>;
}
