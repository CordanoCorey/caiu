/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { ChangeDetectionStrategy, Component, EventEmitter, forwardRef, Input, Output, ViewChild, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { MatDatepicker } from '@angular/material';
import { DateHelper } from '../../shared/date';
export const /** @type {?} */ DATEPICKER_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DatepickerComponent),
    multi: true
};
export class DatepickerComponent {
    constructor() {
        this.placeholder = 'Choose a date';
        this.startView = 'month';
        this.selectedChanged = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        this._value = val;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChange(value) {
        this.value = value;
        if (this.onModelChange) {
            this.onModelChange(value);
        }
    }
    /**
     * @param {?} input
     * @return {?}
     */
    onBlur(input) {
        const /** @type {?} */ date = new Date(input.value);
        if (DateHelper.IsValidDate(date)) {
            this.changeSelected(date);
        }
        else {
            input.value = DateHelper.FormatDate(this.value);
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return this.datepicker.id;
    }
    /**
     * @return {?}
     */
    get opened() {
        return this.datepicker.opened;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.startAt = this.value;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    changeSelected(date) {
        this.onChange(date);
        this.selectedChanged.emit(date);
    }
    /**
     * @return {?}
     */
    close() {
        this.datepicker.close();
    }
    /**
     * @return {?}
     */
    open() {
        this.datepicker.open();
    }
}
DatepickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'iu-datepicker',
                template: `<mat-form-field>
  <input matInput [placeholder]="placeholder" [matDatepicker]="picker" (blur)="onBlur(pickerInput)" (change)="onChange(value)"
    [min]="min" [max]="max" [value]="value" #pickerInput>
  <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
  <mat-datepicker #picker [startAt]="startAt" [startView]="startView" [touchUi]="touchUi" (selectedChanged)="changeSelected($event)"></mat-datepicker>
</mat-form-field>`,
                styles: [`.mat-input-container{float:left}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [DATEPICKER_ACCESSOR]
            },] },
];
/** @nocollapse */
DatepickerComponent.ctorParameters = () => [];
DatepickerComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    placeholder: [{ type: Input }],
    startAt: [{ type: Input }],
    startView: [{ type: Input }],
    touchUi: [{ type: Input }],
    selectedChanged: [{ type: Output }],
    datepicker: [{ type: ViewChild, args: ['picker',] }],
    value: [{ type: Input }]
};
function DatepickerComponent_tsickle_Closure_declarations() {
    /** @type {?} */
    DatepickerComponent.prototype.min;
    /** @type {?} */
    DatepickerComponent.prototype.max;
    /** @type {?} */
    DatepickerComponent.prototype.placeholder;
    /** @type {?} */
    DatepickerComponent.prototype.startAt;
    /** @type {?} */
    DatepickerComponent.prototype.startView;
    /** @type {?} */
    DatepickerComponent.prototype.touchUi;
    /** @type {?} */
    DatepickerComponent.prototype.selectedChanged;
    /** @type {?} */
    DatepickerComponent.prototype.datepicker;
    /** @type {?} */
    DatepickerComponent.prototype.onModelChange;
    /** @type {?} */
    DatepickerComponent.prototype.onTouch;
    /** @type {?} */
    DatepickerComponent.prototype._value;
    /** @type {?} */
    DatepickerComponent.prototype.focused;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY2FpdS9saWJyYXJ5LyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsWUFBWSxFQUNaLFVBQVUsRUFDVixLQUFLLEVBRUwsTUFBTSxFQUNOLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRWxELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUcvQyxNQUFNLENBQUMsdUJBQU0sbUJBQW1CLEdBQVE7SUFDdEMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDO0lBQ2xELEtBQUssRUFBRSxJQUFJO0NBQ1osQ0FBQztBQWNGLE1BQU07SUFlSjsyQkFYdUIsZUFBZTt5QkFFQyxPQUFPOytCQUVsQixJQUFJLFlBQVksRUFBUTtLQU9uQzs7OztJQUVqQixJQUFJLEtBQUs7UUFDUCxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQjs7Ozs7SUFFRCxJQUNJLEtBQUssQ0FBQyxHQUFTO1FBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0tBQ25COzs7OztJQUVELGdCQUFnQixDQUFDLEVBQVk7UUFDM0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7S0FDekI7Ozs7O0lBRUQsaUJBQWlCLENBQUMsRUFBWTtRQUM1QixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztLQUNuQjs7Ozs7SUFFRCxVQUFVLENBQUMsS0FBVztRQUNwQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztLQUNwQjs7Ozs7SUFFRCxRQUFRLENBQUMsS0FBVztRQUNsQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztZQUN2QixJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzNCO0tBQ0Y7Ozs7O0lBRUQsTUFBTSxDQUFDLEtBQVU7UUFDZix1QkFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25DLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0I7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEtBQUssQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDakQ7S0FDRjs7OztJQUVELElBQUksRUFBRTtRQUNKLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztLQUMzQjs7OztJQUVELElBQUksTUFBTTtRQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztLQUMvQjs7OztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDM0I7Ozs7O0lBRUQsY0FBYyxDQUFDLElBQVU7UUFDdkIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwQixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNqQzs7OztJQUVELEtBQUs7UUFDSCxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQ3pCOzs7O0lBRUQsSUFBSTtRQUNGLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDeEI7OztZQXpGRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLFFBQVEsRUFBRTs7Ozs7a0JBS007Z0JBQ2hCLE1BQU0sRUFBRSxDQUFDLGtDQUFrQyxDQUFDO2dCQUM1QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsU0FBUyxFQUFFLENBQUMsbUJBQW1CLENBQUM7YUFDakM7Ozs7O2tCQUdFLEtBQUs7a0JBQ0wsS0FBSzswQkFDTCxLQUFLO3NCQUNMLEtBQUs7d0JBQ0wsS0FBSztzQkFDTCxLQUFLOzhCQUNMLE1BQU07eUJBQ04sU0FBUyxTQUFDLFFBQVE7b0JBWWxCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIENvbXBvbmVudCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgZm9yd2FyZFJlZixcclxuICBJbnB1dCxcclxuICBPbkluaXQsXHJcbiAgT3V0cHV0LFxyXG4gIFZpZXdDaGlsZCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBNYXREYXRlcGlja2VyIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xyXG5cclxuaW1wb3J0IHsgRGF0ZUhlbHBlciB9IGZyb20gJy4uLy4uL3NoYXJlZC9kYXRlJztcclxuXHJcblxyXG5leHBvcnQgY29uc3QgREFURVBJQ0tFUl9BQ0NFU1NPUjogYW55ID0ge1xyXG4gIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVwaWNrZXJDb21wb25lbnQpLFxyXG4gIG11bHRpOiB0cnVlXHJcbn07XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2l1LWRhdGVwaWNrZXInLFxyXG4gIHRlbXBsYXRlOiBgPG1hdC1mb3JtLWZpZWxkPlxyXG4gIDxpbnB1dCBtYXRJbnB1dCBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIiBbbWF0RGF0ZXBpY2tlcl09XCJwaWNrZXJcIiAoYmx1cik9XCJvbkJsdXIocGlja2VySW5wdXQpXCIgKGNoYW5nZSk9XCJvbkNoYW5nZSh2YWx1ZSlcIlxyXG4gICAgW21pbl09XCJtaW5cIiBbbWF4XT1cIm1heFwiIFt2YWx1ZV09XCJ2YWx1ZVwiICNwaWNrZXJJbnB1dD5cclxuICA8bWF0LWRhdGVwaWNrZXItdG9nZ2xlIG1hdFN1ZmZpeCBbZm9yXT1cInBpY2tlclwiPjwvbWF0LWRhdGVwaWNrZXItdG9nZ2xlPlxyXG4gIDxtYXQtZGF0ZXBpY2tlciAjcGlja2VyIFtzdGFydEF0XT1cInN0YXJ0QXRcIiBbc3RhcnRWaWV3XT1cInN0YXJ0Vmlld1wiIFt0b3VjaFVpXT1cInRvdWNoVWlcIiAoc2VsZWN0ZWRDaGFuZ2VkKT1cImNoYW5nZVNlbGVjdGVkKCRldmVudClcIj48L21hdC1kYXRlcGlja2VyPlxyXG48L21hdC1mb3JtLWZpZWxkPmAsXHJcbiAgc3R5bGVzOiBbYC5tYXQtaW5wdXQtY29udGFpbmVye2Zsb2F0OmxlZnR9YF0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgcHJvdmlkZXJzOiBbREFURVBJQ0tFUl9BQ0NFU1NPUl1cclxufSlcclxuZXhwb3J0IGNsYXNzIERhdGVwaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25Jbml0IHtcclxuXHJcbiAgQElucHV0KCkgbWluOiBEYXRlO1xyXG4gIEBJbnB1dCgpIG1heDogRGF0ZTtcclxuICBASW5wdXQoKSBwbGFjZWhvbGRlciA9ICdDaG9vc2UgYSBkYXRlJztcclxuICBASW5wdXQoKSBzdGFydEF0OiBEYXRlO1xyXG4gIEBJbnB1dCgpIHN0YXJ0VmlldzogJ21vbnRoJyB8ICd5ZWFyJyA9ICdtb250aCc7XHJcbiAgQElucHV0KCkgdG91Y2hVaTtcclxuICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xyXG4gIEBWaWV3Q2hpbGQoJ3BpY2tlcicpIGRhdGVwaWNrZXI6IE1hdERhdGVwaWNrZXI8RGF0ZT47XHJcbiAgcHJpdmF0ZSBvbk1vZGVsQ2hhbmdlOiBGdW5jdGlvbjtcclxuICBwcml2YXRlIG9uVG91Y2g6IEZ1bmN0aW9uO1xyXG4gIF92YWx1ZTogRGF0ZTtcclxuICBmb2N1c2VkOiBEYXRlO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHsgfVxyXG5cclxuICBnZXQgdmFsdWUoKTogRGF0ZSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKVxyXG4gIHNldCB2YWx1ZSh2YWw6IERhdGUpIHtcclxuICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogRnVuY3Rpb24pIHtcclxuICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZuO1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IEZ1bmN0aW9uKSB7XHJcbiAgICB0aGlzLm9uVG91Y2ggPSBmbjtcclxuICB9XHJcblxyXG4gIHdyaXRlVmFsdWUodmFsdWU6IERhdGUpIHtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIG9uQ2hhbmdlKHZhbHVlOiBEYXRlKSB7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICBpZiAodGhpcy5vbk1vZGVsQ2hhbmdlKSB7XHJcbiAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkJsdXIoaW5wdXQ6IGFueSkge1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGlucHV0LnZhbHVlKTtcclxuICAgIGlmIChEYXRlSGVscGVyLklzVmFsaWREYXRlKGRhdGUpKSB7XHJcbiAgICAgIHRoaXMuY2hhbmdlU2VsZWN0ZWQoZGF0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbnB1dC52YWx1ZSA9IERhdGVIZWxwZXIuRm9ybWF0RGF0ZSh0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBpZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGVwaWNrZXIuaWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgb3BlbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0ZXBpY2tlci5vcGVuZWQ7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHRoaXMuc3RhcnRBdCA9IHRoaXMudmFsdWU7XHJcbiAgfVxyXG5cclxuICBjaGFuZ2VTZWxlY3RlZChkYXRlOiBEYXRlKSB7XHJcbiAgICB0aGlzLm9uQ2hhbmdlKGRhdGUpO1xyXG4gICAgdGhpcy5zZWxlY3RlZENoYW5nZWQuZW1pdChkYXRlKTtcclxuICB9XHJcblxyXG4gIGNsb3NlKCkge1xyXG4gICAgdGhpcy5kYXRlcGlja2VyLmNsb3NlKCk7XHJcbiAgfVxyXG5cclxuICBvcGVuKCkge1xyXG4gICAgdGhpcy5kYXRlcGlja2VyLm9wZW4oKTtcclxuICB9XHJcblxyXG59XHJcbiJdfQ==