/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Effect, Actions, ofType } from '@ngrx/effects';
import { Observable, of } from 'rxjs';
import { map, switchMap, catchError } from 'rxjs/operators';
import { RouterActions } from './actions';
import { RouterService } from './router.service';
export class RouterEffects {
    /**
     * @param {?} actions$
     * @param {?} router
     */
    constructor(actions$, router) {
        this.actions$ = actions$;
        this.router = router;
        /**
         * All imperative navigation should be performed using this effects
         * so that the state is aware of the navigation.
         */
        this.navigate = this.actions$.pipe(ofType(RouterActions.NAVIGATE), switchMap((action) => this.navigate$(action.payload)));
    }
    /**
     * @param {?} r
     * @return {?}
     */
    navigate$(r) {
        const /** @type {?} */ nav$ = typeof (r) === 'string' ? this.router.navigateByUrl(r) : this.router.navigate(r);
        return nav$.pipe(map(() => RouterActions.navigateSuccess()), catchError((e) => {
            return of(RouterActions.navigateError());
        }));
    }
}
RouterEffects.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RouterEffects.ctorParameters = () => [
    { type: Actions },
    { type: RouterService }
];
tslib_1.__decorate([
    Effect(),
    tslib_1.__metadata("design:type", Observable)
], RouterEffects.prototype, "navigate", void 0);
function RouterEffects_tsickle_Closure_declarations() {
    /** @type {?} */
    RouterEffects.prototype.actionTypes;
    /**
     * All imperative navigation should be performed using this effects
     * so that the state is aware of the navigation.
     * @type {?}
     */
    RouterEffects.prototype.navigate;
    /** @type {?} */
    RouterEffects.prototype.actions$;
    /** @type {?} */
    RouterEffects.prototype.router;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyLmVmZmVjdHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY2FpdS9saWJyYXJ5LyIsInNvdXJjZXMiOlsibGliL3JvdXRlci9yb3V0ZXIuZWZmZWN0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hELE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTVELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDMUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBSWpELE1BQU07Ozs7O0lBWUYsWUFDWSxVQUNBO1FBREEsYUFBUSxHQUFSLFFBQVE7UUFDUixXQUFNLEdBQU4sTUFBTTs7Ozs7d0JBUHVCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUN2RCxNQUFNLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxFQUM5QixTQUFTLENBQUMsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQ2hFO0tBS0k7Ozs7O0lBRUwsU0FBUyxDQUFDLENBQWlCO1FBQ3ZCLHVCQUFNLElBQUksR0FBd0IsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25ILE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNaLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsZUFBZSxFQUFFLENBQUMsRUFDMUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDYixNQUFNLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1NBQzVDLENBQUMsQ0FDTCxDQUFDO0tBQ0w7OztZQTFCSixVQUFVOzs7O1lBUk0sT0FBTztZQUtmLGFBQWE7OztJQVdqQixNQUFNLEVBQUU7c0NBQVcsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRWZmZWN0LCBBY3Rpb25zLCBvZlR5cGUgfSBmcm9tICdAbmdyeC9lZmZlY3RzJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwLCBzd2l0Y2hNYXAsIGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBSb3V0ZXJBY3Rpb25zIH0gZnJvbSAnLi9hY3Rpb25zJztcclxuaW1wb3J0IHsgUm91dGVyU2VydmljZSB9IGZyb20gJy4vcm91dGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuLi9zdG9yZS9tb2RlbHMnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgUm91dGVyRWZmZWN0cyB7XHJcbiAgICBhY3Rpb25UeXBlczogc3RyaW5nW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgaW1wZXJhdGl2ZSBuYXZpZ2F0aW9uIHNob3VsZCBiZSBwZXJmb3JtZWQgdXNpbmcgdGhpcyBlZmZlY3RzXHJcbiAgICAgKiBzbyB0aGF0IHRoZSBzdGF0ZSBpcyBhd2FyZSBvZiB0aGUgbmF2aWdhdGlvbi5cclxuICAgICAqL1xyXG4gICAgQEVmZmVjdCgpIG5hdmlnYXRlOiBPYnNlcnZhYmxlPEFjdGlvbj4gPSB0aGlzLmFjdGlvbnMkLnBpcGUoXHJcbiAgICAgICAgb2ZUeXBlKFJvdXRlckFjdGlvbnMuTkFWSUdBVEUpLFxyXG4gICAgICAgIHN3aXRjaE1hcCgoYWN0aW9uOiBBY3Rpb24pID0+IHRoaXMubmF2aWdhdGUkKGFjdGlvbi5wYXlsb2FkKSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBhY3Rpb25zJDogQWN0aW9ucyxcclxuICAgICAgICBwcml2YXRlIHJvdXRlcjogUm91dGVyU2VydmljZVxyXG4gICAgKSB7IH1cclxuXHJcbiAgICBuYXZpZ2F0ZSQocjogc3RyaW5nIHwgYW55W10pOiBPYnNlcnZhYmxlPEFjdGlvbj4ge1xyXG4gICAgICAgIGNvbnN0IG5hdiQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0eXBlb2YgKHIpID09PSAnc3RyaW5nJyA/IHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwocikgOiB0aGlzLnJvdXRlci5uYXZpZ2F0ZShyKTtcclxuICAgICAgICByZXR1cm4gbmF2JC5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKCkgPT4gUm91dGVyQWN0aW9ucy5uYXZpZ2F0ZVN1Y2Nlc3MoKSksXHJcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvZihSb3V0ZXJBY3Rpb25zLm5hdmlnYXRlRXJyb3IoKSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4iXX0=